DeltaRed is a multi-way constraint solving library for Ruby based on the
the DeltaBlue algorithm presented in "Multi-way versus One-way Constraints
in User Interfaces: Experience with the DeltaBlue Algorithm"
by Sannella et al.  (available http://citeseer.ist.psu.edu/sannella93multiway.html )

== So, er, what does it do?

Constraint solvers, generally, are good for solving problems which fit the
description of "when this value changes, update these other values."  Think
Rake, but for your program's data instead of files.  Rake is actually
a constraint solver itself: when a file is updated, it knows which other
files to update and the how to update them.  Similarly, when a DeltaRed
"variable" changes, DeltaRed knows which other variables to update and
how to update them.

 a, b = DeltaRed.variables(0, 0)
 DeltaRed.constraint! do |c|
   c.formula(b => a) { |v| v * 2 }
 end

 b.value = 3
 p a.value # => 6
 b.value = 2
 p a.value # => 4

The above constraint is like a Rake rule: it declares that <tt>a.value</tt>
depends on <tt>b.value</tt>.  When <tt>b.value</tt> is set to some value,
DeltaRed knows to update <tt>a.value</tt>, and like Rake, the block attached
to the rule tells it how to do that (in this case, <tt>a.value</tt> is obtained
by multiplying <tt>b.value</tt> -- which DeltaRed helpfully passed to the
block -- by 2).

Now, one difference between Rake and DeltaRed is that Rake is a
<em>one-way</em> constraint solver.  You can tell it how to make one
file given another, but that's it.  DeltaRed is a <em>multi-way</em>
constraint solver, which means that you can go <em>both ways</em>:
imagine writing a Rake rule that not only defined how to produce
an <tt>.o</tt> file from a <tt>.c</tt> file, but also how to recover
a <tt>.c</tt> file from an existing <tt>.o</tt> file.  (Of course,
it'd still be up to you to write the decompiler...)

Here's an example of a similar kind of thing with DeltaRed:

 string, number = DeltaRed.variables("0", 0)
 DeltaRed.constraint! do |c|
   c.formula(number => string) { |n| n.to_s }
   c.formula(string => number) { |s| s.to_i }
 end

 string.value = "23"
 p number.value # => 23
 number.value = 7
 p string.value # => "7"

If <tt>string.value</tt> gets set to a different string, DeltaRed will
know to set <tt>number.value</tt> to its integer equivalent, and if
<tt>number.value</tt> is set to a different integer, DeltaRed will
automatically update <tt>string.value</tt>.

== Limitations

While a DeltaRed constraint can encompass multiple formulae which output
to different variables, a formula can only output to a single variable,
and only one formula in a constraint may be active at a time.  Similarly,
while a variable may have multiple constraints which can determine its
value, only one of those constraints may be active at a time; constraints
with higher strengths will take precedence over those with lower strengths.

In the parlance of constraint programming, DeltaRed is a multi-way
local-propagation solver supporting hierarchical constraints but neither
cycles nor multiple outputs.

== What about threads?

DeltaRed is perfectly threadsafe as long as threads don't share variables
or constraints directly or indirectly.  That means you're fine as long as
different threads' variables or constraints don't get connected to each
other by intermediate constraints.  Beyond that, any kind of sharing
will require external synchronization.

